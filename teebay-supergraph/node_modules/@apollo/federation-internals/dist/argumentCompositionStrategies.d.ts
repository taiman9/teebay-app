import { InputType, Schema } from "./definitions";
type TypeSupportValidator = (schema: Schema, type: InputType) => {
    valid: boolean;
    supportedMsg?: string;
};
export type ArgumentCompositionStrategy = {
    name: string;
    isTypeSupported: TypeSupportValidator;
    mergeValues: (values: any[]) => any;
};
export declare const ARGUMENT_COMPOSITION_STRATEGIES: {
    MAX: {
        name: string;
        isTypeSupported: TypeSupportValidator;
        mergeValues: (values: any[]) => number;
    };
    MIN: {
        name: string;
        isTypeSupported: TypeSupportValidator;
        mergeValues: (values: any[]) => number;
    };
    SUM: {
        name: string;
        isTypeSupported: TypeSupportValidator;
        mergeValues: (values: any[]) => any;
    };
    INTERSECTION: {
        name: string;
        isTypeSupported: TypeSupportValidator;
        mergeValues: (values: any[]) => any;
    };
    UNION: {
        name: string;
        isTypeSupported: TypeSupportValidator;
        mergeValues: (values: any[]) => any;
    };
    NULLABLE_AND: {
        name: string;
        isTypeSupported: TypeSupportValidator;
        mergeValues: (values: (boolean | null | undefined)[]) => boolean | null | undefined;
    };
    NULLABLE_MAX: {
        name: string;
        isTypeSupported: TypeSupportValidator;
        mergeValues: (values: any[]) => any;
    };
    NULLABLE_UNION: {
        name: string;
        isTypeSupported: (_: Schema, type: InputType) => {
            valid: boolean;
        };
        mergeValues: (values: any[]) => unknown[] | undefined;
    };
};
export {};
//# sourceMappingURL=argumentCompositionStrategies.d.ts.map