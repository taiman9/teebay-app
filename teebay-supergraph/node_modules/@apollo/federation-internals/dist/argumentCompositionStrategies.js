"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ARGUMENT_COMPOSITION_STRATEGIES = void 0;
const definitions_1 = require("./definitions");
const types_1 = require("./types");
const values_1 = require("./values");
function supportFixedTypes(types) {
    return (schema, type) => {
        const supported = types(schema);
        if (!supported.some((t) => (0, types_1.sameType)(t, type))) {
            return { valid: false, supportedMsg: `type(s) ${supported.join(', ')}` };
        }
        return { valid: true };
    };
}
function supportAnyNonNullArray() {
    return (_, type) => {
        if (!(0, definitions_1.isNonNullType)(type) || !(0, definitions_1.isListType)(type.ofType)) {
            return { valid: false, supportedMsg: 'non nullable list types of any type' };
        }
        return { valid: true };
    };
}
exports.ARGUMENT_COMPOSITION_STRATEGIES = {
    MAX: {
        name: 'MAX',
        isTypeSupported: supportFixedTypes((schema) => [new definitions_1.NonNullType(schema.intType())]),
        mergeValues: (values) => Math.max(...values),
    },
    MIN: {
        name: 'MIN',
        isTypeSupported: supportFixedTypes((schema) => [new definitions_1.NonNullType(schema.intType())]),
        mergeValues: (values) => Math.min(...values),
    },
    SUM: {
        name: 'SUM',
        isTypeSupported: supportFixedTypes((schema) => [new definitions_1.NonNullType(schema.intType())]),
        mergeValues: (values) => values.reduce((acc, val) => acc + val, 0),
    },
    INTERSECTION: {
        name: 'INTERSECTION',
        isTypeSupported: supportAnyNonNullArray(),
        mergeValues: (values) => values.reduce((acc, val) => acc.filter((v1) => val.some((v2) => (0, values_1.valueEquals)(v1, v2))), values[0]),
    },
    UNION: {
        name: 'UNION',
        isTypeSupported: supportAnyNonNullArray(),
        mergeValues: (values) => values.reduce((acc, val) => {
            const newValues = val.filter((v1) => !acc.some((v2) => (0, values_1.valueEquals)(v1, v2)));
            return acc.concat(newValues);
        }, []),
    },
    NULLABLE_AND: {
        name: 'NULLABLE_AND',
        isTypeSupported: supportFixedTypes((schema) => [schema.booleanType()]),
        mergeValues: (values) => values.reduce((acc, next) => {
            if (acc === null || acc === undefined) {
                return next;
            }
            else if (next === null || next === undefined) {
                return acc;
            }
            else {
                return acc && next;
            }
        }, undefined),
    },
    NULLABLE_MAX: {
        name: 'NULLABLE_MAX',
        isTypeSupported: supportFixedTypes((schema) => [schema.intType(), new definitions_1.NonNullType(schema.intType())]),
        mergeValues: (values) => values.reduce((a, b) => a !== undefined && b !== undefined ? Math.max(a, b) : a !== null && a !== void 0 ? a : b, undefined),
    },
    NULLABLE_UNION: {
        name: 'NULLABLE_UNION',
        isTypeSupported: (_, type) => ({ valid: (0, definitions_1.isListType)(type) }),
        mergeValues: (values) => {
            if (values.every((v) => v === undefined)) {
                return undefined;
            }
            const combined = new Set();
            for (const subgraphValues of values) {
                if (Array.isArray(subgraphValues)) {
                    for (const value of subgraphValues) {
                        combined.add(value);
                    }
                }
            }
            return Array.from(combined);
        }
    }
};
//# sourceMappingURL=argumentCompositionStrategies.js.map